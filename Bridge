int high[MAXN] = {0}, depth[MAXN] = {0}, n, ROOT;
bool vis[MAXN] = {false};
vector<pair<int, int> > result;
vi adj[MAXN];
void FindBridges(int node, int prev = -1)
{
	depth[node] = prev == -1?0: depth[prev]+1;
	vis[node] = true;
	high[node] = depth[node];
	int sz = SZ(adj[node]), child;
	REP(i,sz){
		child = adj[node][i];
		if(child == prev)	continue;
		if(vis[child]){
			high[node] = min(high[node], depth[child]);  
		}
		else{
			FindBridges(child, node);
			high[node] = min(high[node], high[child]);
			if(high[child] > depth[node]){
				result.PB(MP(node, child));
			}
		}
	}
}

void initialise()
{
	result.clear();
	REPc(i,0,n){
		adj[i].clear();  
		high[i] = 0, depth[i] = 0, vis[i] = false;
	}
}

void solve()
{
	REP1(i,n){
		if(vis[i])	continue;
		ROOT = i;
		FindBridges(ROOT, -1);
	}
}
