/*	Author: Ankit Sultana
 * * * * * * * * * * * * * * * * */
#include <iostream>
#include <map>
#include <algorithm>
#include <vector>
#include <set>
#include <cassert>
#define LL long long
#define PB push_back
#define SWAP(a,b) a=a+b-(b=a)
#define MP make_pair
#define vi vector<int>
#define vll vector<LL>
#define REP(i,n)	for(__typeof(n) i = 0; i < n; i++)
#define REP1(i,n)	for(__typeof(n) i = 1; i <= n; i++)
#define REPc(i,j,n)	for(__typeof(n) i = j; i <= n; i++)
#define F first
#define S second
#define smax(a, b) a = max(a, b)
#define smin(a, b) a = min(a, b)
#define mod 1000000007ll
#define SZ(a) int(a.size())
#define SZll(a) (LL)(a.size())
#define MAXN 100003

using namespace std;

template<typename T> T gcd(T a, T b) { return b == 0?a: gcd(b, a % b); }
template<typename T> T LCM(T a, T b) { return a*(b/gcd(a, b)); }
template<typename T> T expo(T b, T e, const T &m){if(e <= 1)return e == 0?1: b;\
	return (e&1) == 0?expo((b*b)%m, e>>1, m): (b*expo((b*b)%m, e>>1, m))%m;}
template<typename T> T modinv(T a) { return expo(a, mod-2, mod); }


/* Number the edges
 * * * * * * * * * * */
int high[MAXN] = {0}, depth[MAXN] = {0}, n, ROOT, E;
bool vis[MAXN] = {false};
vector<pair<int, int> > result;
vector<pair<int, int> >  adj[MAXN];

/* Bridge Tree Stuff
 * * * * * * * * * * */
bool is_bridge[MAXN] = {false};
int comp[MAXN] = {0};
int global_iter = 1;
vi tree[MAXN];

void FindBridges(int node, int prev = -1)
{
	depth[node] = prev == -1?0: depth[prev]+1;
	vis[node] = true;
	high[node] = depth[node];
	int sz = SZ(adj[node]), child;
	REP(i,sz){
		child = adj[node][i].F;
		if(child == prev)	continue;
		if(vis[child]){
			high[node] = min(high[node], depth[child]);  
		}
		else{
			FindBridges(child, node);
			high[node] = min(high[node], high[child]);
			if(high[child] > depth[node]){
				// result.PB(MP(node, child));
				is_bridge[adj[node][i].S] = true;
			}
		}
	}
}

void initialise()
{
	result.clear();
	REPc(i,0,n){
		adj[i].clear();  
		high[i] = 0, depth[i] = 0, vis[i] = false;
	}
	// Take Input
}

// Call make_bridge_tree(1, 1, vis);
void compress_bridge_components(int node, int comp_no, bool vis[])
{
	if(vis[node])	return ;
	comp[node] = comp_no;
	vis[node] = true;
	int sz = int(adj[node].size());
	REP(i,sz){
		if(vis[adj[node][i].F])	continue;  
		compress_bridge_components(adj[node][i].F, is_bridge[adj[node][i].S]?++global_iter: comp_no, vis);
	}
}

void make_bridge_tree()
{
	REP1(i,n){
		REP(j,SZ(adj[i])){
			if(is_bridge[adj[i][j].S]){
				tree[comp[i]].PB(comp[adj[i][j].F]);
			}
		}
	}
}

void solve()
{
	REP1(i,n){
		if(vis[i])	continue;
		ROOT = i;
		FindBridges(ROOT, 0);
	}
	// Found the Bridges
	bool vis[MAXN] = {false};
	compress_bridge_components(1, 1, vis);
	make_bridge_tree();
}

int main()
{
	ios_base::sync_with_stdio(false);
	initialise();
	solve();
	return 0;  
}
