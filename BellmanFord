/* Bellman Ford: 
 * 		Complexity: O(V*E)
 * * * * * * * * * * * * * */
int n, m, dp[MAXN];
vi adj[MAXN], wt[MAXN];
void initialize()
{
	REP1(i,n) {
		adj[i].clear();  
		wt[i].clear();
		dp[i] = iNF;
	}
}
void bellman_ford(int v, int start_vertex = -1)
{
	dp[v] = 0;
	vi p(n+1, -1);
	int x;
	REP(i,n) {
		x = -1;
		REP1(k,n) {
			REP(j,SZ(adj[k])) {
				int other = adj[k][j];
				if(dp[k] < iNF) {
					if(dp[other] > dp[k] + wt[k][j]) {
						dp[other] = dp[k] + wt[k][j];
						p[other] = k;
						x = other;
					}
				}
			}
		}
	}
	/* Check Negative Cycle */
	if(x != -1) {
		cout<<"Negative Cycle Found\n";  
		/* Print Negative Cycle */
		/* * * * * * * * * * * * * * * * * * * * * 
		int y = x;
		REP(i,n) {
			y = p[y];  
		}
		vi path;
		for(int cur = y; ;cur = p[cur]) {
			path.PB(cur);  
			if(cur == y && path.size() > 1)	break;
		}
		reverse(path.begin(), path.end());
		REP(i,SZ(path)) {
			cout<<path[i]<<' ';  
		}
		* * * * * * * * * * * * * * * * * * * * */
		return ;
	}
	/* Print Path */
	/* * * * * * * * * * * * * * * * * * * * * 
	assert(start_vertex != -1);
	vi path;
	for(int cur = start_vertex; cur != -1; cur = p[cur]) {
		path.PB(cur);
	}
	reverse(path.begin(), path.end());
	REP(i,SZ(path)) {
		cout<<path[i]<<' ';  
	}
	* * * * * * * * * * * * * * * * * * * * */
}
